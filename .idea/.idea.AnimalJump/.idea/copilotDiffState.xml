<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/_Game/Scripts/Core/Piece.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/_Game/Scripts/Core/Piece.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;public class Piece : MonoBehaviour&#10;{&#10;    [Header(&quot;Score Settings&quot;)]&#10;    [SerializeField] int _scoreValue = 1;&#10;&#10;    [Header(&quot;Landing Zone Settings&quot;)]&#10;    [SerializeField] Collider col;&#10;&#10;    [Tooltip(&quot;Tỷ lệ vùng an toàn (0-1). Có thể bị override bởi LevelManager&quot;)]&#10;    [SerializeField] float _safeLandingZoneRatio = 0.7f;&#10;&#10;    [Header(&quot;Coin Settings&quot;)]&#10;    [SerializeField] private GameObject _coinObject;&#10;&#10;    [Tooltip(&quot;Xác suất xuất hiện coin (0-1). 0.2 = 20% chance&quot;)]&#10;    [SerializeField] private float _coinSpawnChance = 0.2f;&#10;&#10;    [Header(&quot;Heart Settings&quot;)]&#10;    [SerializeField] private GameObject _heartObject;&#10;&#10;    [Tooltip(&quot;Xác suất xuất hiện heart (0-1). 0.15 = 15% chance&quot;)]&#10;    [SerializeField] private float _heartSpawnChance = 0.15f;&#10;&#10;    public  bool         isIgnoreTriggerSetScore = false;&#10;    private LevelManager _levelManager;&#10;    private Coin         _coin;&#10;    private Heart        _heart;&#10;&#10;    [Header(&quot;Visual&quot;)]&#10;    [SerializeField] MeshRenderer _renderer;&#10;&#10;    [SerializeField] GameData _data;&#10;&#10;    [field: SerializeField]&#10;    public float HalfWidth { get; private set; }&#10;&#10;    bool _isGameOver      = false;&#10;    bool _playerHasLanded = false; // Track nếu player đã từng landed&#10;    bool _playerHasLeft   = false; // Track nếu player đã rời khỏi thực sự&#10;    bool _isPlayerOnPiece = false; // Track nếu player đang trên piece (collision active)&#10;&#10;    // Checkpoint system&#10;    public static bool      IsReviving = false; // Flag để disable scoring khi revive&#10;    private       Coroutine _fallCoroutine; // Lưu reference coroutine để có thể cancel khi revive&#10;&#10;    public static event Action            OnGameOver;&#10;    public static event Action&lt;Vector3&gt;   OnLastPieceExit;&#10;    public static event Action&lt;int&gt;       OnGettingScore;&#10;    public static event Action&lt;Transform&gt; OnSafeLanding; // Trigger khi player đáp đúng vùng an toàn → set checkpoint&#10;&#10;    private void OnEnable()&#10;    {&#10;        GameManager.OnRevive         += Revive;&#10;        GameManager.OnPlatformFreeze += StopFalling; // Stop coroutine khi freeze&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        GameManager.OnRevive         -= Revive;&#10;        GameManager.OnPlatformFreeze -= StopFalling;&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        _renderer.material = _data.GetRandomMaterial;&#10;&#10;        // Lấy safe landing zone từ LevelManager&#10;        _levelManager = FindFirstObjectByType&lt;LevelManager&gt;();&#10;&#10;        if (_levelManager != null)&#10;        {&#10;            _safeLandingZoneRatio = _levelManager.GetSafeLandingZoneRatio();&#10;        }&#10;&#10;        // Random spawn pickups (chỉ spawn Heart HOẶC Coin, không cả hai)&#10;        InitializePickups();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Random spawn Heart hoặc Coin (ưu tiên Heart nếu cả hai đều trúng)&#10;    /// CHỈ 1 trong 2 được hiển thị, không bao giờ cả hai cùng lúc&#10;    /// &lt;/summary&gt;&#10;    private void InitializePickups()&#10;    {&#10;        bool heartSpawned = false;&#10;&#10;        // Lấy components trước&#10;        if (_heartObject != null)&#10;        {&#10;            _heart = _heartObject.GetComponent&lt;Heart&gt;();&#10;        }&#10;&#10;        if (_coinObject != null)&#10;        {&#10;            _coin = _coinObject.GetComponent&lt;Coin&gt;();&#10;        }&#10;&#10;        // Try spawn Heart trước (ưu tiên cao hơn)&#10;        if (_heart != null)&#10;        {&#10;            float randomValue = UnityEngine.Random.Range(0f, 1f);&#10;&#10;            if (randomValue &lt;= _heartSpawnChance)&#10;            {&#10;                // Spawn Heart → ẨN Coin&#10;                _heart.Show();&#10;                if (_coin != null) _coin.Hide();&#10;&#10;                heartSpawned = true;&#10;&#10;                return; // Dừng luôn, không spawn coin&#10;            }&#10;            else&#10;            {&#10;                _heart.Hide();&#10;            }&#10;        }&#10;&#10;        // Chỉ đến đây nếu KHÔNG có Heart&#10;        // Random spawn Coin&#10;        if (_coin != null)&#10;        {&#10;            float randomValue = UnityEngine.Random.Range(0f, 1f);&#10;&#10;            if (randomValue &lt;= _coinSpawnChance)&#10;            {&#10;                _coin.Show();&#10;            }&#10;            else&#10;            {&#10;                _coin.Hide();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void Revive() { _isGameOver = false; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Stop platform fall coroutine khi freeze (revive system)&#10;    /// Tránh platform rơi khi player revive về piece này&#10;    /// &lt;/summary&gt;&#10;    private void StopFalling()&#10;    {&#10;        if (_fallCoroutine != null)&#10;        {&#10;            StopCoroutine(_fallCoroutine);&#10;            _fallCoroutine = null;&#10;&#10;            // Reset flags để có thể reuse piece&#10;            _playerHasLeft = false;&#10;        }&#10;    }&#10;&#10;    private void OnCollisionEnter(Collision c)&#10;    {&#10;        // Đánh dấu player đã landed và đang trên piece&#10;        _playerHasLanded = true;&#10;        _isPlayerOnPiece = true;&#10;&#10;        // Nếu đang reviving → Resume platforms và skip scoring&#10;        if (IsReviving)&#10;        {&#10;            IsReviving = false;&#10;&#10;            // Resume platforms thông qua GameManager&#10;            GameManager gameManager = FindFirstObjectByType&lt;GameManager&gt;();&#10;&#10;            if (gameManager != null)&#10;            {&#10;                gameManager.ResumePlatformsFromRevival();&#10;            }&#10;&#10;            SoundController.GetInstance().PlayAudio(AudioType.LANDING);&#10;&#10;            return; // Skip tất cả logic scoring/coin/heart&#10;        }&#10;&#10;        // Tính khoảng cách từ player đến tâm của piece&#10;        float xDistanceToCenter = Mathf.Abs(c.transform.position.x - transform.position.x);&#10;&#10;        // Tính vùng an toàn (giữa piece)&#10;        float safeZoneWidth = col.bounds.size.x * _safeLandingZoneRatio * 0.5f;&#10;&#10;        // Nếu đáp xa tâm (ngoài vùng an toàn) = đáp lệch mép → Mất health&#10;        if (xDistanceToCenter &gt; safeZoneWidth)&#10;        {&#10;            // Trigger event để GameManager xử lý (mất health)&#10;            OnGameOver?.Invoke();&#10;        }&#10;        else&#10;        {&#10;            // Đáp chính xác vào vùng an toàn = set checkpoint + được điểm&#10;            Debug.Log(&quot;[Piece] Safe landing!&quot;);&#10;            OnSafeLanding?.Invoke(transform);&#10;&#10;            if (!isIgnoreTriggerSetScore)&#10;            {&#10;                // Cộng điểm&#10;                OnGettingScore?.Invoke(_scoreValue);&#10;                LeanTween.moveLocalY(gameObject, -.3f, .2f).setEase(LeanTweenType.easeOutQuad).setLoopPingPong(1);&#10;&#10;                // Spawn floating score&#10;                FloatingScore floatingScore = Instantiate(_data.GetFloatingScore);&#10;                floatingScore.Spawn(transform.position, _scoreValue);&#10;                Destroy(floatingScore.gameObject, 1f);&#10;            }&#10;        }&#10;&#10;        SoundController.GetInstance().PlayAudio(AudioType.LANDING);&#10;    }&#10;&#10;    private void OnCollisionStay(Collision c)&#10;    {&#10;        // Player vẫn đang chạm piece&#10;        _isPlayerOnPiece = true;&#10;    }&#10;&#10;    private void OnCollisionExit(Collision c)&#10;    {&#10;        // Đánh dấu player không còn chạm piece&#10;        _isPlayerOnPiece = false;&#10;&#10;        // Chỉ cho platform rơi nếu:&#10;        // 1. Không phải game over&#10;        // 2. Player đã từng landed trên piece này&#10;        // 3. Chưa rơi trước đó&#10;        if (!_isGameOver &amp;&amp; _playerHasLanded &amp;&amp; !_playerHasLeft)&#10;        {&#10;            _playerHasLeft = true;&#10;&#10;            // Delay để đảm bảo player đã nhảy xa thực sự&#10;            _fallCoroutine = StartCoroutine(CheckAndFallPlatform());&#10;&#10;            OnLastPieceExit?.Invoke(transform.position);&#10;        }&#10;    }&#10;&#10;    IEnumerator CheckAndFallPlatform()&#10;    {&#10;        // Tìm PlayerMovement để check xem player có đang jump không&#10;        PlayerMovement playerMovement = FindObjectOfType&lt;PlayerMovement&gt;();&#10;&#10;        // Đợi 0.1s để check xem collision có quay lại không (do unparent)&#10;        yield return new WaitForSeconds(0.1f);&#10;&#10;        // KIỂM TRA: Player có thực sự đang jumping không?&#10;        bool playerIsJumping = playerMovement != null &amp;&amp; playerMovement.IsJumping;&#10;&#10;        // Nếu sau 0.1s player vẫn không chạm lại VÀ đang jumping = đã nhảy xa thực sự&#10;        if (!_isPlayerOnPiece &amp;&amp; playerIsJumping)&#10;        {&#10;            yield return new WaitForSeconds(0.4f); // Delay thêm trước khi rơi&#10;&#10;            transform.parent.parent.gameObject.AddComponent&lt;Rigidbody&gt;();&#10;            Destroy(transform.parent.parent.gameObject, 2f);&#10;&#10;            _fallCoroutine = null; // Cleanup coroutine reference&#10;        }&#10;        else&#10;        {&#10;            _playerHasLeft = false; // Reset flag&#10;            _fallCoroutine = null; // Cleanup coroutine reference&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;public class Piece : MonoBehaviour&#10;{&#10;    [Header(&quot;Score Settings&quot;)]&#10;    [SerializeField] int _scoreValue = 1;&#10;&#10;    [Header(&quot;Landing Zone Settings&quot;)]&#10;    [SerializeField] Collider col;&#10;&#10;    [Tooltip(&quot;Tỷ lệ vùng an toàn (0-1). Có thể bị override bởi LevelManager&quot;)]&#10;    [SerializeField] float _safeLandingZoneRatio = 0.7f;&#10;&#10;    [Header(&quot;Coin Settings&quot;)]&#10;    [SerializeField] private GameObject _coinObject;&#10;&#10;    [Tooltip(&quot;Xác suất xuất hiện coin (0-1). 0.2 = 20% chance&quot;)]&#10;    [SerializeField] private float _coinSpawnChance = 0.2f;&#10;&#10;    [Header(&quot;Heart Settings&quot;)]&#10;    [SerializeField] private GameObject _heartObject;&#10;&#10;    [Tooltip(&quot;Xác suất xuất hiện heart (0-1). 0.15 = 15% chance&quot;)]&#10;    [SerializeField] private float _heartSpawnChance = 0.15f;&#10;&#10;    public  bool         isIgnoreTriggerSetScore = false;&#10;    private LevelManager _levelManager;&#10;    private Coin         _coin;&#10;    private Heart        _heart;&#10;&#10;    [Header(&quot;Visual&quot;)]&#10;    [SerializeField] MeshRenderer _renderer;&#10;&#10;    [SerializeField] GameData _data;&#10;&#10;    [field: SerializeField]&#10;    public float HalfWidth { get; private set; }&#10;&#10;    bool _isGameOver      = false;&#10;    bool _playerHasLanded = false; // Track nếu player đã từng landed&#10;    bool _playerHasLeft   = false; // Track nếu player đã rời khỏi thực sự&#10;    bool _isPlayerOnPiece = false; // Track nếu player đang trên piece (collision active)&#10;&#10;    // Checkpoint system&#10;    public static bool      IsReviving = false; // Flag để disable scoring khi revive&#10;    private       Coroutine _fallCoroutine; // Lưu reference coroutine để có thể cancel khi revive&#10;&#10;    public static event Action            OnGameOver;&#10;    public static event Action&lt;Vector3&gt;   OnLastPieceExit;&#10;    public static event Action&lt;int&gt;       OnGettingScore;&#10;    public static event Action&lt;Transform&gt; OnSafeLanding; // Trigger khi player đáp đúng vùng an toàn → set checkpoint&#10;&#10;    private void OnEnable()&#10;    {&#10;        GameManager.OnRevive         += Revive;&#10;        GameManager.OnPlatformFreeze += StopFalling; // Stop coroutine khi freeze&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        GameManager.OnRevive         -= Revive;&#10;        GameManager.OnPlatformFreeze -= StopFalling;&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        _renderer.material = _data.GetRandomMaterial;&#10;&#10;        // Lấy safe landing zone từ LevelManager&#10;        _levelManager = FindFirstObjectByType&lt;LevelManager&gt;();&#10;&#10;        if (_levelManager != null)&#10;        {&#10;            _safeLandingZoneRatio = _levelManager.GetSafeLandingZoneRatio();&#10;        }&#10;&#10;        // Random spawn pickups (chỉ spawn Heart HOẶC Coin, không cả hai)&#10;        InitializePickups();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Random spawn Heart hoặc Coin (ưu tiên Heart nếu cả hai đều trúng)&#10;    /// CHỈ 1 trong 2 được hiển thị, không bao giờ cả hai cùng lúc&#10;    /// &lt;/summary&gt;&#10;    private void InitializePickups()&#10;    {&#10;        bool heartSpawned = false;&#10;&#10;        // Lấy components trước&#10;        if (_heartObject != null)&#10;        {&#10;            _heart = _heartObject.GetComponent&lt;Heart&gt;();&#10;        }&#10;&#10;        if (_coinObject != null)&#10;        {&#10;            _coin = _coinObject.GetComponent&lt;Coin&gt;();&#10;        }&#10;&#10;        // Try spawn Heart trước (ưu tiên cao hơn)&#10;        if (_heart != null)&#10;        {&#10;            float randomValue = UnityEngine.Random.Range(0f, 1f);&#10;&#10;            if (randomValue &lt;= _heartSpawnChance)&#10;            {&#10;                // Spawn Heart → ẨN Coin&#10;                _heart.Show();&#10;                if (_coin != null) _coin.Hide();&#10;&#10;                heartSpawned = true;&#10;&#10;                return; // Dừng luôn, không spawn coin&#10;            }&#10;            else&#10;            {&#10;                _heart.Hide();&#10;            }&#10;        }&#10;&#10;        // Chỉ đến đây nếu KHÔNG có Heart&#10;        // Random spawn Coin&#10;        if (_coin != null)&#10;        {&#10;            float randomValue = UnityEngine.Random.Range(0f, 1f);&#10;&#10;            if (randomValue &lt;= _coinSpawnChance)&#10;            {&#10;                _coin.Show();&#10;            }&#10;            else&#10;            {&#10;                _coin.Hide();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void Revive() { _isGameOver = false; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Stop platform fall coroutine khi freeze (revive system)&#10;    /// Tránh platform rơi khi player revive về piece này&#10;    /// &lt;/summary&gt;&#10;    private void StopFalling()&#10;    {&#10;        if (_fallCoroutine != null)&#10;        {&#10;            StopCoroutine(_fallCoroutine);&#10;            _fallCoroutine = null;&#10;&#10;            // Reset flags để có thể reuse piece&#10;            _playerHasLeft = false;&#10;        }&#10;    }&#10;&#10;    private void OnCollisionEnter(Collision c)&#10;    {&#10;        // Đánh dấu player đã landed và đang trên piece&#10;        _playerHasLanded = true;&#10;        _isPlayerOnPiece = true;&#10;&#10;        // Nếu đang reviving → Resume platforms và skip scoring&#10;        if (IsReviving)&#10;        {&#10;            IsReviving = false;&#10;&#10;            // Resume platforms thông qua GameManager&#10;            GameManager gameManager = FindFirstObjectByType&lt;GameManager&gt;();&#10;&#10;            if (gameManager != null)&#10;            {&#10;                gameManager.ResumePlatformsFromRevival();&#10;            }&#10;&#10;            SoundController.GetInstance().PlayAudio(AudioType.LANDING);&#10;&#10;            return; // Skip tất cả logic scoring/coin/heart&#10;        }&#10;&#10;        // Tính khoảng cách từ player đến tâm của piece&#10;        float xDistanceToCenter = Mathf.Abs(c.transform.position.x - transform.position.x);&#10;&#10;        // Tính vùng an toàn (giữa piece)&#10;        float safeZoneWidth = col.bounds.size.x * _safeLandingZoneRatio * 0.5f;&#10;&#10;        // Nếu đáp xa tâm (ngoài vùng an toàn) = đáp lệch mép → Mất health&#10;        if (xDistanceToCenter &gt; safeZoneWidth)&#10;        {&#10;            // Trigger event để GameManager xử lý (mất health)&#10;            OnGameOver?.Invoke();&#10;        }&#10;        else&#10;        {&#10;            // Đáp chính xác vào vùng an toàn = set checkpoint + được điểm&#10;            Debug.Log(&quot;[Piece] Safe landing!&quot;);&#10;            OnSafeLanding?.Invoke(transform);&#10;&#10;            if (!isIgnoreTriggerSetScore)&#10;            {&#10;                // Cộng điểm&#10;                OnGettingScore?.Invoke(_scoreValue);&#10;                LeanTween.moveLocalY(gameObject, -.3f, .2f).setEase(LeanTweenType.easeOutQuad).setLoopPingPong(1);&#10;&#10;                // Spawn floating score&#10;                FloatingScore floatingScore = Instantiate(_data.GetFloatingScore);&#10;                floatingScore.Spawn(transform.position, _scoreValue);&#10;                Destroy(floatingScore.gameObject, 1f);&#10;            }&#10;        }&#10;&#10;        SoundController.GetInstance().PlayAudio(AudioType.LANDING);&#10;    }&#10;&#10;    private void OnCollisionStay(Collision c)&#10;    {&#10;        // Player vẫn đang chạm piece&#10;        _isPlayerOnPiece = true;&#10;    }&#10;&#10;    private void OnCollisionExit(Collision c)&#10;    {&#10;        // Đánh dấu player không còn chạm piece&#10;        _isPlayerOnPiece = false;&#10;&#10;        // Chỉ cho platform rơi nếu:&#10;        // 1. Không phải game over&#10;        // 2. Player đã từng landed trên piece này&#10;        // 3. Chưa rơi trước đó&#10;        if (!_isGameOver &amp;&amp; _playerHasLanded &amp;&amp; !_playerHasLeft)&#10;        {&#10;            _playerHasLeft = true;&#10;&#10;            // Delay để đảm bảo player đã nhảy xa thực sự&#10;            _fallCoroutine = StartCoroutine(CheckAndFallPlatform());&#10;&#10;            OnLastPieceExit?.Invoke(transform.position);&#10;        }&#10;    }&#10;&#10;    IEnumerator CheckAndFallPlatform()&#10;    {&#10;        // Tìm PlayerMovement để check xem player có đang jump không&#10;        PlayerMovement playerMovement = FindObjectOfType&lt;PlayerMovement&gt;();&#10;&#10;        // Đợi 0.1s để check xem collision có quay lại không (do unparent)&#10;        yield return new WaitForSeconds(0.1f);&#10;&#10;        // KIỂM TRA: Player có thực sự đang jumping không?&#10;        bool playerIsJumping = playerMovement != null &amp;&amp; playerMovement.IsJumping;&#10;&#10;        // Nếu sau 0.1s player vẫn không chạm lại VÀ đang jumping = đã nhảy xa thực sự&#10;        if (!_isPlayerOnPiece &amp;&amp; playerIsJumping)&#10;        {&#10;            yield return new WaitForSeconds(0.4f); // Delay thêm trước khi rơi&#10;&#10;            transform.parent.parent.gameObject.AddComponent&lt;Rigidbody&gt;();&#10;            Destroy(transform.parent.parent.gameObject, 2f);&#10;&#10;            _fallCoroutine = null; // Cleanup coroutine reference&#10;        }&#10;        else&#10;        {&#10;            _playerHasLeft = false; // Reset flag&#10;            _fallCoroutine = null; // Cleanup coroutine reference&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>